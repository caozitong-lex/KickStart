总结目前做过的十几道dfs题目：

1. 二叉树的dfs

1.1 二叉树dfs模板
递归实现分为两种实现思路 分治和遍历

遍历实现：
分为接口函数和遍历函数 接口函数是题目给定的函数 包括了规定的函数参数和返回值 遍历函数则是递归函数 无返回值 函数参数自定义
函数参数如下：
主参数：来自于接口函数的参数 是解题的起点 如根节点 
全局笔记本：这是接口函数的题解 是遍历函数存在的目的 由于递归函数无返回值 只能通过函数参数的引用来传递结果 遍历函数通过递归遍历逐步填充全局笔记本 递归结束之后笔记本填充完毕
节点笔记本：和当前节点的状态相关的笔记本 记录更多信息 在递归调用的参数中直接更新 和节点绑定 如深度 往往用来做一些更多的功能 如比较 记录 等等
局部笔记本：和当前节点的状态相关的笔记本 和节点笔记本等价 不同的是需要回溯 节点笔记本由不是赋值表达式 所以值和节点绑定 
辅助全局笔记本：记录和局部节点无关的全局信息 往往作为最值 等（遍历实现中较少 往往出现在分治实现的分治函数中）
注意回溯时机：
回溯的核心是 刚进入节点的状态（进入函数第一行） 和 离开函数的状态（函数最后一行）是相同的 因为前序表示第一次从根节点进入 后序表示即将返回根节点 而中序是递归部分 变量传入到递归函数 进入下一层 无论怎么折腾 都和当前节点空间中的变量无关 （理论语法上 传递索引在子函数中修改会影响父函数 因此只有全局笔记本是引用 但递归每层都做了回溯 因此中序递归函数不会更改当前节点空间的变量）


->遍历实现的核心：在于前序 如何在每个节点中填写维护全局笔记本 完成最终解

接口函数只需要做三件事：
构造遍历函数的参数
调用遍历函数
返回解

分治实现：
分治实现不需要helper函数 使用的是题目所给的参数和返回值
因此需要在函数初始建立局部笔记本来构造当前节点产生的局部解 然后返回传递局部笔记本
->分治实现的核心：在于后序 如何通过在不同节点之间传递自己的局部笔记本 合并成最终解

1.2 二叉树求树高
分治实现：当前树的高 = 左右子树高的较大值 + 1
->分治实现的分解 是从底部子树迭代向上的
递归实现：遍历每一条根-叶的路径 打擂台比较最长就是树高 全局笔记本同时充当最值擂台
参数：主参数（根节点） 全局笔记本（树高 也充当了辅助全局笔记本） 节点笔记本（当前深度）

1.3 二叉树路径和
分治实现：分治实现的核心是对左右子树的解的合并 往往解是左右子树的性质 而路径长度无法合并 
递归实现：遍历每一条根-叶的路径 找到符合长度的
参数：主参数（根节点 目标长度） 全局笔记本（路径集合）辅助笔记本（当前路径 当前路径长度）
回溯: push-左递归-右递归-pop
进入该节点时 参数中的节点和节点状态不同步 比如传入节点是i 而状态仍然是i-1节点的状态 因此前序将状态更新为i节点 后检查中序递归到两个i+1节点 后序恢复到i-1节点的状态

1.4 最大子树和 -> 树的最长连续递增序列
分治实现：无法直接合并解 因为子树的最大子树和和当前树的最大子树和没有直接合并关系 但可以间接合并 子树和 然后通过一个外部全局变量作全局笔记本 在每个节点中和当前节点的子树和打擂台 最终返回打过擂台的合并解

1.5 最大子树和的树根节点 
分治实现：之前 虽然无法直接合并 导致合并解和题目解不一致 但可以通过打擂台把合并解转化为题目解/全局笔记本 再返回 而这道题的合并解要求是根节点 这显然无法合并也无法转化 因此必须要写成接口函数和分治函数来调和合并解和返回解的矛盾 分治函数中返回直接解 接口函数返回间接解/题目解 
此外 必须有新的参数来记录全局题目解/间接解 这就是全局笔记本的作用  另一个参数是辅助全局笔记本 用以辅助生成全局笔记本 它不是局部笔记本或节点笔记本 并非某个节点的状态 而是全局最值 
返回解/局部笔记本记录的是当前节点的直接解（当前和） 主参数可以得到当前节点间接解（当前根节点） 全局笔记本是全局间接解（最大根节点） 辅助笔记本是全局直接解（最大和）
过程就是 每个节点合并出当前节点的直接解 和辅助笔记本比较得到全局直接解 根据对应主参数得到对应的全局间接解

1.6 验证一棵树是平衡树/搜索树 
分治实现中打包结果的经典题目

1.7 最大子树平均和的 树根节点 
结合了 打包解 和 打擂台 
分治实现：子树和的关系可以直接合并得到 平均和则无法直接合并 需要同时知道子树的节点数和子树和 因此返回解需要返回两个内容 因此需要重做局部笔记本/返回解/当前节点直接解 
还有一种实现方法是既然已经打包 节点数和节点和的整体作为直接解 那不如进一步把直接解和间接解打包成新的结构 也就是不需要通过直接解得到间接解 而是把解构造成[间接解 直接解]的结构体 这样全局笔记本 和 局部笔记本 的结构一致 可以直接用来比较 不需要维护辅助笔记本




1.8词语阶梯2（图的dfs）
图的dfs和树类似 区别在于需要一个哈希表记录元素是否访问过  回溯操作和树相同  

2. 求子集类问题 
求子集类问题 每个节点都是一个解 但没有子树的合并关系 因此只能遍历实现 
2.1 求子集
参数：
主参数（待选元素数组） 全局笔记本（子集集合）局部笔记本（当前子集）节点笔记本（递归深度/选取位序）
两种实现方式 多叉树和二叉树

二叉树思想：生成选择元素（选/不选）的k步n长 根据k步n长进一步得到所有子集 这里的k步n长 指有k个元素 组成n长的序列 有多少种
前序是退出条件 一般是递归深度到达数组长度 
由于节点索引比节点状态先一步 因此先更新节点状态/局部笔记本 再更新全局笔记本 否则 若先更新全局笔记本1,i-1 再更新局部笔记本1,i 加入最后一个元素i 再次循环会退出 但加入了最后元素的局部笔记本没有被加入全局笔记本 这样会遗漏空集 在接口函数中补充
不取的递归前后没有push-pop回溯是因为不取的递归 状态本身就和前序时相同 因此不需要push自然也不需要pop

多叉树思想：直接生成选择元素（1，2，3...）的所有子集 
前序没有退出条件 而是直接加入子集集合 这就导致不需要先记录局部再记录全局 因为不会因为前序时检查索引超标而不让记录全局
特殊在于 树的递归 参数传入的是节点指针 表明递归到当前节点 然后对当前节点的子节点继续递归
而序列的递归的参数传入的是index 这不是某个节点 而是一组节点（可以想象多叉树 传入index表明的是一层节点而非某一个） 所以 要for循环遍历所有节点 每个节点都对下一层所有子节点递归 每个节点都要push-back回溯 保证每个节点的前后序状态相同 同理 递归部分在树中是写了好几个 对左递归再对右递归 而传入index只需要写一个 表明对所有子节点递归
递归的终点由for循环变量控制 循环遍历在递归中也会增加 因此到达边界后无法继续循环 从而进入循环中的递归

2.2 带重复求子集
带重复元素意味着求子集会出现重复 如[1 2 3 1]
会取到重复子集[1 2 3]和[2 3 1]
因此可以先对数组排序 正常求子集 再在接口函数中对结果去重即可 

2.3 带重复指定和求子集
在排序去重的基础上增加条件判断 和剪枝 节点状态除了子集 还有子集和 也作为局部笔记本加入到参数中
二叉树思想：
前序的递归终点判断 除了递归深度 还有剪枝条件：如果当前和已经大于目标 表明无需进一步递归选择下个元素 直接返回
记录全局笔记本的部分中 只有子集之和符合要求才加入集合 
递归部分则需要将两个局部笔记本都回溯
多叉树思想：
前序的记录笔记本部分加入筛选条件
for循环中 递归部分需要将两个局部笔记本都回溯 同时递归需要添加条件 当子集和小于目标时才继续递归（因为要先更新局部笔记本得到本节点状态才能判断 所以if包含递归语句而不包含push-pop  也可以先在if中暂时加上值判断本节点状态 再push递归pop） 和二叉树相同 剪枝是为了控制进一步递归与否 因此一个在控制递归的for循环中的递归语句前 一个在前序递归终点处

2.4 划分回文串
题目问有多少种切割方式 同时也是在问 [1,2,3...n]切割点的子集 每个元素代表在某个位置切一刀 而求子集问题 也可以理解为[1,2,3...n]切割点的切/不切的k步n长 进而表示切割点集合 
题目的难点在于 
· 没有直接给出待选择元素 这次不是选择元素 而是选择切割点
· 增加了剪枝条件：每个切割点之间的部分是 回文的 所以在构造当前结果时就需要判断
· 没有直接问切割点集合 而是返回切割结果 这就需要递归取得切割点集合后进一步构造解 当前结果并不是选择的点 而是上个点到当前切割点之间的字符串

参数：
主参数（待选择字符串间隔） 全局笔记本（切割结果集合） 局部笔记本（当前切割） 参数笔记本（递归深度/切割点序号）
多叉树思想：
前序不再直接添加当前结果 因为切割结果必须包含一个完整的字符串 因此需要检查当前递归深度到达末尾才能添加当前结果
传入index为上一个选择的切割点 for循环遍历当前切割点 递归前增加剪枝 只有两个切割点之间为回文 才可以加入当前结果 并递归 如果不是回文 不必继续递归（if包括递归和push-pop 因为剪枝条件不需要更新节点状态就可以判断） 

这题较灵活 不再单纯的给你元素求子集 也不再单纯的返回求得的子集


3. k步n长排列问题
3.1 火柴棒
火柴棒问题不是子集问题 而是k步n长排列问题 因为结果长度是固定的 都是对每个元素的选择进行决策 并且并不是直接对数组元素k步n长 而是对每一步的选择边k步n长（1/2/3/4） 长度为数组长度 因此使用 二叉树思想
剪枝条件为 若当前边已超过边长则无需尝试
参数：
主参数（数组） 全局笔记本（能否组成） 局部笔记本（四边长度）辅助笔记本（目标边长） 节点笔记本（递归深度）

前序递归终点 同样是检查递归深度 由于题目的解是布尔值 因此不需要构造解的步骤 全局笔记本是一个布尔值 当到达最深递归时 检查四边长度是否相同和为周长 更新布尔值即可
接着for循环递归四个选择 同理 由于传入的是index 表明该递归函数是一层（四个）节点  每个选择都是一个节点 因此对每个节点push-递归-pop

这道题较灵活 是先找出选择1/2/3/4 再求k步n长 其实和求子集类似 求子集也找出选择取/不取 再求k步n长


3.2 合法括号序列
不是子集问题 而是对指定数量的括号进行k步n长 每一步选择有2个 生成所有n长序列 二叉树思想可以直接使用 并且每一步的选择也很清晰 左/右
参数
主参数（括号数量 总递归深度） 全局笔记本（排列集合） 节点笔记本（左右括号使用数量和当前排列）
这里左右括号数量有灵活的作用  一来可以充当当前递归深度 而来可以用来帮助剪枝

前序递归终点 通过总递归深度和左右括号判断递归是否应该结束 结束前把当前排列加入集合中 和火柴棒问题一样 k步n长理应等到递归深度到达终点时再记录全局笔记本 但求子集问题中 选择不是1/2/3/4或左/右 而是取/不取 对于不取的选择 
递归所有选择部分 因为没有局部笔记本 全部写作了节点笔记本 因此没有回溯


3.3 
矩阵形式的排列问题 本质上每一步选择有n 生成所有n长序列 同时增加了剪枝条件 
参数：
主参数（n 提供了递归深度和每一步选择空间） 全局笔记本（所有放置） 局部笔记本（当前放置 当前访问状态） 节点笔记本（递归深度）
当前访问状态是帮助剪枝
前序递归终点 当递归深度到达最深时 把当前结果加入集合 记录全局笔记本
递归部分 每层有n个选择 每个节点都进行递归  包括回溯


